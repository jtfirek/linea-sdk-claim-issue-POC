"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClaimTxSender = void 0;
const MessageRepository_1 = require("../repositories/MessageRepository");
const enum_1 = require("../../utils/enum");
const enums_1 = require("../utils/enums");
const Message_entity_1 = require("../entity/Message.entity");
const errorHandlers_1 = require("../../errorHandlers");
const constants_1 = require("../../utils/constants");
const helpers_1 = require("../utils/helpers");
class ClaimTxSender {
    constructor(dataSource, messageServiceContract, config, direction) {
        this.dataSource = dataSource;
        this.messageServiceContract = messageServiceContract;
        this.direction = direction;
        this.maxNonceDiff = Math.max(config.claiming.maxNonceDiff ?? constants_1.DEFAULT_MAX_NONCE_DIFF, 0);
        this.shouldStopListening = false;
        this.messageRepository = new MessageRepository_1.MessageRepository(this.dataSource);
        this.feeRecipient = config.claiming.feeRecipientAddress;
        this.pollingInterval = config.listener.pollingInterval ?? constants_1.DEFAULT_LISTENER_INTERVAL;
        this.profitMargin = config.claiming.profitMargin ?? constants_1.DEFAULT_PROFIT_MARGIN;
        this.maxRetry = config.claiming.maxNumberOfRetries ?? constants_1.DEFAULT_MAX_NUMBER_OF_RETRIES;
        this.retryDelayInSeconds = config.claiming.retryDelayInSeconds ?? constants_1.DEFAULT_RETRY_DELAY_IN_SECONDS;
        this.maxFeePerGasFromConfig = BigInt(config.claiming.maxFeePerGas ?? constants_1.DEFAULT_MAX_FEE_PER_GAS);
        this.maxClaimGasLimit = BigInt(config.claiming.maxClaimGasLimit ?? constants_1.DEFAULT_MAX_CLAIM_GAS_LIMIT);
    }
    async start() {
        this.logger.info(`Starting ${this.direction} ClaimTxSender...`);
        while (!this.shouldStopListening) {
            await this.listenForReadyToBeClaimedMessages(this.pollingInterval);
        }
    }
    stop() {
        this.logger.info(`Stopping ${this.direction} ClaimTxSender...`);
        this.shouldStopListening = true;
        this.logger.info(`${this.direction} ClaimTxSender stopped.`);
    }
    async listenForReadyToBeClaimedMessages(interval) {
        let nextMessageToClaim = null;
        try {
            const nonce = await this.getNonce();
            if (!nonce && nonce !== 0) {
                this.logger.error(`Nonce returned from getNonce is an invalid value (e.g. null or undefined)`);
                return;
            }
            const { maxFeePerGas } = await this.messageServiceContract.get1559Fees();
            nextMessageToClaim = await this.messageRepository.getFirstMessageToClaim(this.direction, this.originContractAddress, maxFeePerGas, this.profitMargin, this.maxRetry, this.retryDelayInSeconds);
            if (!nextMessageToClaim) {
                await (0, helpers_1.wait)(this.pollingInterval);
                return;
            }
            if (BigInt(nextMessageToClaim.fee) === 0n && this.profitMargin !== 0) {
                this.logger.warn(`Zero fee found in this message: ${JSON.stringify(nextMessageToClaim)}`);
                await this.messageRepository.updateMessage(nextMessageToClaim.messageHash, nextMessageToClaim.direction, {
                    status: enums_1.MessageStatus.ZERO_FEE,
                });
                return;
            }
            const messageStatus = await this.messageServiceContract.getMessageStatus(nextMessageToClaim.messageHash);
            if (messageStatus === enum_1.OnChainMessageStatus.CLAIMED) {
                this.logger.info(`Found already claimed message: ${JSON.stringify(nextMessageToClaim)}`);
                await this.messageRepository.updateMessage(nextMessageToClaim.messageHash, nextMessageToClaim.direction, {
                    status: enums_1.MessageStatus.CLAIMED_SUCCESS,
                });
                return;
            }
            const { estimatedGasLimit, threshold } = await this.calculateGasEstimationAndThresHold(nextMessageToClaim);
            const txGasLimit = this.getGasLimit(estimatedGasLimit);
            if (!txGasLimit) {
                await this.messageRepository.updateMessage(nextMessageToClaim.messageHash, nextMessageToClaim.direction, {
                    status: enums_1.MessageStatus.NON_EXECUTABLE,
                });
                this.logger.warn(`Estimated gas limit (${estimatedGasLimit}) is higher than the max allowed gas limit (${this.maxClaimGasLimit}) for this message: ${JSON.stringify(nextMessageToClaim)}`);
                return;
            }
            await this.messageRepository.updateMessage(nextMessageToClaim.messageHash, nextMessageToClaim.direction, {
                claimGasEstimationThreshold: threshold,
            });
            const isTxUnderPriced = await this.isTransactionUnderPriced(txGasLimit, nextMessageToClaim.fee, maxFeePerGas);
            if (isTxUnderPriced) {
                this.logger.warn(`Fee underpriced found in this message with txGasLimit=${txGasLimit} and maxFeePerGas=${maxFeePerGas}: ${JSON.stringify(nextMessageToClaim)}`);
                await this.messageRepository.updateMessage(nextMessageToClaim.messageHash, nextMessageToClaim.direction, {
                    status: enums_1.MessageStatus.FEE_UNDERPRICED,
                });
                return;
            }
            if (await this.isRateLimitExceeded(nextMessageToClaim.fee, nextMessageToClaim.value)) {
                this.logger.warn(`Rate limit exceeded on L1 for this message: ${JSON.stringify(nextMessageToClaim)}`);
                await this.messageRepository.updateMessage(nextMessageToClaim.messageHash, nextMessageToClaim.direction, {
                    claimGasEstimationThreshold: undefined,
                });
                await (0, helpers_1.wait)(this.pollingInterval);
                return;
            }
            await this.executeClaimTransaction(nextMessageToClaim, nonce, txGasLimit);
        }
        catch (e) {
            const parsedError = errorHandlers_1.ErrorParser.parseErrorWithMitigation(e);
            if (parsedError?.mitigation && !parsedError.mitigation.shouldRetry) {
                if (nextMessageToClaim) {
                    await this.messageRepository.updateMessage(nextMessageToClaim.messageHash, nextMessageToClaim.direction, {
                        status: enums_1.MessageStatus.NON_EXECUTABLE,
                    });
                }
            }
            this.logger.warnOrError(e, `Error found in listenForReadyToBeClaimedMessages | Failed message: ${JSON.stringify(nextMessageToClaim)} | Founded error: ${e.name} | Parsed error:${JSON.stringify(parsedError)}`);
            await (0, helpers_1.wait)(interval);
        }
    }
    async getNonce() {
        const lastTxNonce = await this.messageRepository.getLastTxNonce(this.direction);
        let nonce = await this.messageServiceContract.getCurrentNonce();
        if (lastTxNonce) {
            if (lastTxNonce - nonce > this.maxNonceDiff) {
                this.logger.warn(`Last recorded nonce in db (${lastTxNonce}) is higher than the latest nonce from blockchain (${nonce}) and exceeds the limit (${this.maxNonceDiff}), paused the claim message process now`);
                return null;
            }
            nonce = Math.max(nonce, lastTxNonce + 1);
        }
        return nonce;
    }
    async calculateGasEstimationAndThresHold(message) {
        const gasEstimation = await this.messageServiceContract.estimateClaimGas({
            messageSender: message.messageSender,
            destination: message.destination,
            fee: BigInt(message.fee),
            value: BigInt(message.value),
            calldata: message.calldata,
            messageNonce: BigInt(message.messageNonce),
            feeRecipient: this.feeRecipient,
            messageHash: message.messageHash,
        }, { ...(await this.messageServiceContract.get1559Fees()) });
        return {
            threshold: parseFloat((BigInt(message.fee) / gasEstimation).toString()),
            estimatedGasLimit: gasEstimation,
        };
    }
    getGasLimit(gasLimit) {
        if (gasLimit <= this.maxClaimGasLimit) {
            return gasLimit;
        }
        else {
            return null;
        }
    }
    async isTransactionUnderPriced(gasLimit, messageFee, maxFeePerGas) {
        const maxFeePerGasVal = maxFeePerGas ?? (await this.messageServiceContract.get1559Fees()).maxFeePerGas;
        if (gasLimit * maxFeePerGasVal * BigInt(Math.floor(this.profitMargin * constants_1.PROFIT_MARGIN_MULTIPLIER)) >
            BigInt(messageFee) * BigInt(constants_1.PROFIT_MARGIN_MULTIPLIER)) {
            return true;
        }
        return false;
    }
    async executeClaimTransaction(message, nonce, gasLimit) {
        await this.messageRepository.manager.transaction(async (entityManager) => {
            await entityManager.update(Message_entity_1.MessageEntity, { messageHash: message.messageHash, direction: message.direction }, {
                claimTxCreationDate: new Date(),
                claimTxNonce: nonce,
                status: enums_1.MessageStatus.PENDING,
                ...(message.status === enums_1.MessageStatus.FEE_UNDERPRICED
                    ? { claimNumberOfRetry: message.claimNumberOfRetry + 1, claimLastRetriedAt: new Date() }
                    : {}),
            });
            const tx = await this.messageServiceContract.claim({
                messageSender: message.messageSender,
                destination: message.destination,
                fee: BigInt(message.fee),
                value: BigInt(message.value),
                calldata: message.calldata,
                messageNonce: BigInt(message.messageNonce),
                feeRecipient: this.feeRecipient,
                messageHash: message.messageHash,
            }, { nonce, gasLimit, ...(await this.messageServiceContract.get1559Fees()) });
            await entityManager.update(Message_entity_1.MessageEntity, { messageHash: message.messageHash, direction: message.direction }, {
                claimTxGasLimit: parseInt(tx.gasLimit.toString()),
                claimTxMaxFeePerGas: tx.maxFeePerGas ?? undefined,
                claimTxMaxPriorityFeePerGas: tx.maxPriorityFeePerGas ?? undefined,
                claimTxHash: tx.hash,
            });
        });
    }
}
exports.ClaimTxSender = ClaimTxSender;
