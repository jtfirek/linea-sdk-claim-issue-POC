"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClaimStatusWatcher = void 0;
const MessageRepository_1 = require("../repositories/MessageRepository");
const enums_1 = require("../utils/enums");
const constants_1 = require("../../utils/constants");
const helpers_1 = require("../utils/helpers");
const enum_1 = require("../../utils/enum");
class ClaimStatusWatcher {
    constructor(dataSource, messageServiceContract, config, direction) {
        this.dataSource = dataSource;
        this.messageServiceContract = messageServiceContract;
        this.direction = direction;
        this.submissionTimeout = config.claiming.messageSubmissionTimeout ?? constants_1.DEFAULT_MESSAGE_SUBMISSION_TIMEOUT;
        this.shouldStopListening = false;
        this.messageRepository = new MessageRepository_1.MessageRepository(this.dataSource);
        this.pollingInterval = config.listener.pollingInterval ?? constants_1.DEFAULT_LISTENER_INTERVAL;
        this.maxTxRetries = config.claiming.maxTxRetries ?? constants_1.DEFAULT_MAX_TX_RETRIES;
        this.messageBeingRetry = { message: null, retries: 0 };
    }
    async start() {
        this.logger.info(`Starting ${this.direction} ClaimStatusWatcher...`);
        while (!this.shouldStopListening) {
            await this.waitForReceipt(this.pollingInterval);
        }
    }
    stop() {
        this.logger.info(`Stopping ${this.direction} ClaimStatusWatcher...`);
        this.shouldStopListening = true;
        this.logger.info(`${this.direction} ClaimStatusWatcher stopped.`);
    }
    async waitForReceipt(interval) {
        let message = null;
        try {
            message = await this.messageRepository.getFirstPendingMessage(this.direction);
            if (!message || !message.claimTxHash) {
                await (0, helpers_1.wait)(interval);
                return;
            }
            const receipt = await this.messageServiceContract.provider.getTransactionReceipt(message.claimTxHash);
            if (!receipt) {
                if (message.updatedAt && new Date().getTime() - message.updatedAt?.getTime() > this.submissionTimeout) {
                    this.logger.warn(`Retring to claim message: ${JSON.stringify(message)}`);
                    this.messageBeingRetry = { message, retries: 0 };
                    const transactionReceipt = await this.retryTransaction(message.claimTxHash, message.messageHash);
                    this.logger.warn(`Retried to claim succeed: message: ${JSON.stringify(message)} | Transaction receipt: ${JSON.stringify(transactionReceipt)}`);
                }
                await (0, helpers_1.wait)(interval);
                return;
            }
            await this.updateReceiptStatus(receipt);
        }
        catch (e) {
            this.logger.error(`Error found in waitForReceipt: ${JSON.stringify(e)}`);
            await (0, helpers_1.wait)(interval);
        }
    }
    async retryTransaction(transactionHash, messageHash) {
        const currentBlockNumber = await this.messageServiceContract.getCurrentBlockNumber();
        try {
            const messageStatus = await this.messageServiceContract.getMessageStatus(messageHash, {
                blockTag: currentBlockNumber,
            });
            if (messageStatus === enum_1.OnChainMessageStatus.CLAIMED) {
                const receipt = await this.messageServiceContract.provider.getTransactionReceipt(transactionHash);
                if (!receipt) {
                    this.logger.warn(`Calling retryTransaction again as message of ${messageHash} was claimed but txn receipt of ${transactionHash} is not avaiable yet.`);
                    await (0, helpers_1.wait)(this.pollingInterval);
                    return await this.retryTransaction(transactionHash, messageHash);
                }
                return receipt;
            }
            this.messageBeingRetry.retries++;
            this.logger.warn(`Retry number ${this.messageBeingRetry.retries}`);
            const tx = await this.messageServiceContract.retryTransactionWithHigherFee(transactionHash, await this.messageServiceContract.get1559Fees());
            const receipt = await tx.wait();
            if (!receipt) {
                throw new Error(`RetryTransaction: Transaction receipt not found after retry transaction. Tx hash: ${tx.hash}`);
            }
            await this.messageRepository.updateMessage(messageHash, this.direction, {
                claimTxGasLimit: parseInt(tx.gasLimit.toString()),
                claimTxMaxFeePerGas: tx?.maxFeePerGas ?? undefined,
                claimTxMaxPriorityFeePerGas: tx?.maxPriorityFeePerGas ?? undefined,
                claimTxHash: tx?.hash,
            });
            return receipt;
        }
        catch (e) {
            this.logger.error(`Transaction retry failed with the following error: ${JSON.stringify(e)}`);
            while (currentBlockNumber === (await this.messageServiceContract.getCurrentBlockNumber())) {
                this.logger.info("Waiting for next block before retrying the transaction.");
                await (0, helpers_1.wait)(this.pollingInterval);
            }
            if (this.messageBeingRetry.retries > this.maxTxRetries) {
                this.logger.error(`Max number of retries exceeded for this message: ${JSON.stringify(this.messageBeingRetry.message)} | Manual intervention is needed as soon as possible.`);
            }
            return await this.retryTransaction(transactionHash, messageHash);
        }
    }
    async updateReceiptStatus(receipt) {
        if (receipt.status === 0) {
            const isRateLimitExceeded = await this.isRateLimitExceededError(receipt.hash);
            if (isRateLimitExceeded) {
                await this.messageRepository.updateMessageByTransactionHash(receipt.hash, this.direction, {
                    status: enums_1.MessageStatus.SENT,
                    claimGasEstimationThreshold: undefined,
                });
                return;
            }
            await this.messageRepository.updateMessageByTransactionHash(receipt.hash, this.direction, {
                status: enums_1.MessageStatus.CLAIMED_REVERTED,
            });
            this.logger.warn(`CLAIMED_REVERTED: Message with tx hash ${receipt.hash} has been reverted.`);
            return;
        }
        await this.messageRepository.updateMessageByTransactionHash(receipt.hash, this.direction, {
            status: enums_1.MessageStatus.CLAIMED_SUCCESS,
        });
        this.logger.info(`CLAIMED_SUCCESS: Message with tx hash ${receipt.hash} has been claimed.`);
    }
}
exports.ClaimStatusWatcher = ClaimStatusWatcher;
