import { DataSource } from "typeorm";
import { MessageRepository } from "../repositories/MessageRepository";
import { L1NetworkConfig, MessageInDb, L2NetworkConfig } from "../utils/types";
import { LineaLogger } from "../../logger";
import { Direction } from "../utils/enums";
import { L1MessageServiceContract, L2MessageServiceContract } from "../../contracts";
export declare abstract class ClaimTxSender<TMessageServiceContract extends L1MessageServiceContract | L2MessageServiceContract> {
    private dataSource;
    private readonly messageServiceContract;
    protected readonly direction: Direction;
    protected logger: LineaLogger;
    protected maxNonceDiff: number;
    protected shouldStopListening: boolean;
    protected messageRepository: MessageRepository;
    protected originContractAddress: string;
    protected pollingInterval: number;
    protected feeRecipient?: string;
    protected profitMargin: number;
    protected maxRetry: number;
    protected retryDelayInSeconds: number;
    protected maxFeePerGasFromConfig: bigint;
    protected maxClaimGasLimit: bigint;
    constructor(dataSource: DataSource, messageServiceContract: TMessageServiceContract, config: L1NetworkConfig | L2NetworkConfig, direction: Direction);
    start(): Promise<void>;
    stop(): void;
    protected listenForReadyToBeClaimedMessages(interval: number): Promise<void>;
    protected getNonce(): Promise<number | null>;
    protected calculateGasEstimationAndThresHold(message: MessageInDb): Promise<{
        threshold: number;
        estimatedGasLimit: bigint;
    }>;
    protected getGasLimit(gasLimit: bigint): bigint | null;
    protected isTransactionUnderPriced(gasLimit: bigint, messageFee: string, maxFeePerGas?: bigint): Promise<boolean>;
    protected executeClaimTransaction(message: MessageInDb, nonce: number, gasLimit: bigint): Promise<void>;
    protected abstract isRateLimitExceeded(messageFee: string, messageValue: string): Promise<boolean>;
}
