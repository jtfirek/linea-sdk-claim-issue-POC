"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.L1ClaimStatusWatcher = void 0;
const logger_1 = require("../../logger");
const enums_1 = require("../utils/enums");
const ClaimStatusWatcher_1 = require("./ClaimStatusWatcher");
class L1ClaimStatusWatcher extends ClaimStatusWatcher_1.ClaimStatusWatcher {
    constructor(dataSource, l1MessageServiceContract, config, loggerOptions) {
        super(dataSource, l1MessageServiceContract, config, enums_1.Direction.L2_TO_L1);
        this.l1MessageServiceContract = l1MessageServiceContract;
        this.logger = (0, logger_1.getLogger)(L1ClaimStatusWatcher.name, loggerOptions);
    }
    async isRateLimitExceededError(transactionHash) {
        try {
            const tx = await this.l1MessageServiceContract.provider.getTransaction(transactionHash);
            const errorEncodedData = await this.l1MessageServiceContract.provider.call({
                to: tx?.to,
                from: tx?.from,
                nonce: tx?.nonce,
                gasLimit: tx?.gasLimit,
                data: tx?.data,
                value: tx?.value,
                chainId: tx?.chainId,
                accessList: tx?.accessList,
                maxPriorityFeePerGas: tx?.maxPriorityFeePerGas,
                maxFeePerGas: tx?.maxFeePerGas,
            });
            const error = this.l1MessageServiceContract.contract.interface.parseError(errorEncodedData);
            return error?.name === "RateLimitExceeded";
        }
        catch (e) {
            return false;
        }
    }
}
exports.L1ClaimStatusWatcher = L1ClaimStatusWatcher;
