"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MessageRepository = void 0;
const typeorm_1 = require("typeorm");
const Message_entity_1 = require("../entity/Message.entity");
const errors_1 = require("../utils/errors");
const enums_1 = require("../utils/enums");
const mappers_1 = require("../utils/mappers");
const helpers_1 = require("../utils/helpers");
class MessageRepository extends typeorm_1.Repository {
    constructor(dataSource) {
        super(Message_entity_1.MessageEntity, dataSource.createEntityManager());
        this.dataSource = dataSource;
    }
    async findByMessageHash(message, direction) {
        try {
            const messageInDb = await this.findOneBy({
                messageHash: message.messageHash,
                direction,
            });
            if (!messageInDb) {
                return null;
            }
            return (0, mappers_1.mapMessageEntityToMessage)(messageInDb);
        }
        catch (err) {
            throw new errors_1.DatabaseAccessError(enums_1.DatabaseRepoName.MessageRepository, enums_1.DatabaseErrorType.Read, err, message);
        }
    }
    async insertMessage(message) {
        try {
            const messageInDb = await this.findOneBy({
                messageHash: message.messageHash,
                direction: message.direction,
            });
            if (!messageInDb) {
                await this.manager.save(Message_entity_1.MessageEntity, (0, mappers_1.mapMessageToMessageEntity)(message));
            }
        }
        catch (err) {
            throw new errors_1.DatabaseAccessError(enums_1.DatabaseRepoName.MessageRepository, enums_1.DatabaseErrorType.Insert, err, message);
        }
    }
    async updateMessage(messageHash, direction, messagePropertiesToUpdate) {
        let messageInDb;
        try {
            const messageInDb = await this.findOneBy({
                messageHash,
                direction,
            });
            if (messageInDb) {
                await this.save((0, mappers_1.mapMessageToMessageEntity)({ ...messageInDb, ...messagePropertiesToUpdate }));
            }
        }
        catch (err) {
            throw new errors_1.DatabaseAccessError(enums_1.DatabaseRepoName.MessageRepository, enums_1.DatabaseErrorType.Update, err, {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                ...messageInDb,
                ...messagePropertiesToUpdate,
            });
        }
    }
    async updateMessageByTransactionHash(transactionHash, direction, messagePropertiesToUpdate) {
        try {
            const messageInDb = await this.findOneBy({
                claimTxHash: transactionHash,
                direction,
            });
            if (messageInDb) {
                await this.manager.save(Message_entity_1.MessageEntity, (0, mappers_1.mapMessageToMessageEntity)({ ...messageInDb, ...messagePropertiesToUpdate }));
            }
        }
        catch (err) {
            throw new errors_1.DatabaseAccessError(enums_1.DatabaseRepoName.MessageRepository, enums_1.DatabaseErrorType.Update, err);
        }
    }
    async saveMessages(messages) {
        try {
            await this.manager.save(Message_entity_1.MessageEntity, messages.map(mappers_1.mapMessageToMessageEntity));
        }
        catch (err) {
            throw new errors_1.DatabaseAccessError(enums_1.DatabaseRepoName.MessageRepository, enums_1.DatabaseErrorType.Insert, err);
        }
    }
    async deleteMessages(msBeforeNowToDelete) {
        try {
            const d = new Date();
            d.setTime(d.getTime() - msBeforeNowToDelete);
            const formattedDateStr = d.toISOString().replace("T", " ").replace("Z", "");
            return await this.createQueryBuilder("message")
                .delete()
                .where("message.status IN(:...statuses)", {
                statuses: [
                    enums_1.MessageStatus.CLAIMED_SUCCESS,
                    enums_1.MessageStatus.CLAIMED_REVERTED,
                    enums_1.MessageStatus.EXCLUDED,
                    enums_1.MessageStatus.ZERO_FEE,
                ],
            })
                .andWhere("message.updated_at < :updated_before", { updated_before: formattedDateStr })
                .execute();
        }
        catch (err) {
            throw new errors_1.DatabaseAccessError(enums_1.DatabaseRepoName.MessageRepository, enums_1.DatabaseErrorType.Delete, err);
        }
    }
    async getFirstMessageToClaim(direction, contractAddress, currentGasPrice, gasEstimationMargin, maxRetry, retryDelay) {
        try {
            return await this.createQueryBuilder("message")
                .where("message.direction = :direction", { direction })
                .andWhere("message.messageContractAddress = :contractAddress", { contractAddress })
                .andWhere("message.status IN(:...statuses)", {
                statuses: [enums_1.MessageStatus.ANCHORED, enums_1.MessageStatus.FEE_UNDERPRICED],
            })
                .andWhere("message.claimNumberOfRetry < :maxRetry", { maxRetry })
                .andWhere(new typeorm_1.Brackets((qb) => {
                qb.where("message.claimLastRetriedAt IS NULL").orWhere("message.claimLastRetriedAt < :lastRetriedDate", {
                    lastRetriedDate: (0, helpers_1.subtractSeconds)(new Date(), retryDelay).toISOString(),
                });
            }))
                .andWhere(new typeorm_1.Brackets((qb) => {
                qb.where("message.claimGasEstimationThreshold > :threshold", {
                    threshold: parseFloat(currentGasPrice.toString()) * gasEstimationMargin,
                }).orWhere("message.claimGasEstimationThreshold IS NULL");
            }))
                .orderBy("CAST(message.status as CHAR)", "ASC")
                .addOrderBy("message.claimGasEstimationThreshold", "DESC")
                .addOrderBy("message.sentBlockNumber", "ASC")
                .getOne();
        }
        catch (err) {
            throw new errors_1.DatabaseAccessError(enums_1.DatabaseRepoName.MessageRepository, enums_1.DatabaseErrorType.Read, err);
        }
    }
    async getLatestMessageSent(direction, contractAddress) {
        try {
            const pendingMessages = await this.find({
                where: {
                    direction,
                    messageContractAddress: contractAddress,
                },
                take: 1,
                order: {
                    createdAt: "DESC",
                },
            });
            if (pendingMessages.length === 0)
                return null;
            return pendingMessages[0];
        }
        catch (err) {
            throw new errors_1.DatabaseAccessError(enums_1.DatabaseRepoName.MessageRepository, enums_1.DatabaseErrorType.Read, err);
        }
    }
    async getNFirstMessageSent(direction, limit, contractAddress) {
        try {
            return await this.find({
                where: {
                    direction,
                    status: enums_1.MessageStatus.SENT,
                    messageContractAddress: contractAddress,
                },
                take: limit,
                order: {
                    sentBlockNumber: "ASC",
                },
            });
        }
        catch (err) {
            throw new errors_1.DatabaseAccessError(enums_1.DatabaseRepoName.MessageRepository, enums_1.DatabaseErrorType.Read, err);
        }
    }
    async getLastTxNonce(direction) {
        try {
            const message = await this.createQueryBuilder("message")
                .select("MAX(message.claimTxNonce)", "lastTxNonce")
                .where("message.direction = :direction", { direction })
                .getRawOne();
            if (!message.lastTxNonce) {
                return null;
            }
            return message.lastTxNonce;
        }
        catch (err) {
            throw new errors_1.DatabaseAccessError(enums_1.DatabaseRepoName.MessageRepository, enums_1.DatabaseErrorType.Read, err);
        }
    }
    async getFirstPendingMessage(direction) {
        try {
            const message = await this.createQueryBuilder("message")
                .where("message.direction = :direction", { direction })
                .andWhere("message.status = :status", { status: enums_1.MessageStatus.PENDING })
                .orderBy("message.claimTxNonce", "ASC")
                .getOne();
            return message;
        }
        catch (err) {
            throw new errors_1.DatabaseAccessError(enums_1.DatabaseRepoName.MessageRepository, enums_1.DatabaseErrorType.Read, err);
        }
    }
}
exports.MessageRepository = MessageRepository;
