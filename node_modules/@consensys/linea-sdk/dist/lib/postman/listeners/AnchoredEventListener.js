"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AnchoredEventListener = void 0;
const errorHandlers_1 = require("../../errorHandlers");
const constants_1 = require("../../utils/constants");
const enum_1 = require("../../utils/enum");
const MessageRepository_1 = require("../repositories/MessageRepository");
const enums_1 = require("../utils/enums");
const helpers_1 = require("../utils/helpers");
class AnchoredEventListener {
    constructor(dataSource, messageServiceContract, config, direction) {
        this.messageServiceContract = messageServiceContract;
        this.direction = direction;
        this.maxFetchMessagesFromDb = Math.max(config.listener.maxFetchMessagesFromDb ?? constants_1.DEFAULT_MAX_FETCH_MESSAGES_FROM_DB, 0);
        this.shouldStopListening = false;
        this.messageRepository = new MessageRepository_1.MessageRepository(dataSource);
        this.pollingInterval = config.listener.pollingInterval ?? constants_1.DEFAULT_LISTENER_INTERVAL;
    }
    async start() {
        this.logger.info(`Starting ${this.direction} AnchoredEventListener...`);
        while (!this.shouldStopListening) {
            this.listenForMessageAnchoringEvents();
            await (0, helpers_1.wait)(this.pollingInterval);
        }
    }
    stop() {
        this.logger.info(`Stopping ${this.direction} AnchoredEventListener...`);
        this.shouldStopListening = true;
        this.logger.info(`${this.direction} AnchoredEventListener stopped.`);
    }
    async listenForMessageAnchoringEvents() {
        try {
            const messagesSent = await this.messageRepository.getNFirstMessageSent(this.direction, this.maxFetchMessagesFromDb, this.originContractAddress);
            if (messagesSent.length === this.maxFetchMessagesFromDb) {
                this.logger.warn(`Limit of messages sent to listen reached (${this.maxFetchMessagesFromDb}).`);
            }
            if (messagesSent.length === 0) {
                return;
            }
            const latestBlockNumber = await this.messageServiceContract.getCurrentBlockNumber();
            for (const message of messagesSent) {
                const messageStatus = await this.messageServiceContract.getMessageStatus(message.messageHash, {
                    blockTag: latestBlockNumber,
                });
                if (messageStatus === enum_1.OnChainMessageStatus.CLAIMABLE) {
                    await this.messageRepository.updateMessage(message.messageHash, message.direction, {
                        status: enums_1.MessageStatus.ANCHORED,
                    });
                    this.logger.info(`Message hash ${message.messageHash} has been anchored.`);
                }
                if (messageStatus === enum_1.OnChainMessageStatus.CLAIMED) {
                    await this.messageRepository.updateMessage(message.messageHash, message.direction, {
                        status: enums_1.MessageStatus.CLAIMED_SUCCESS,
                    });
                    this.logger.info(`Message with hash ${message.messageHash} has already been claimed.`);
                }
            }
        }
        catch (e) {
            const parsedError = errorHandlers_1.ErrorParser.parseErrorWithMitigation(e);
            this.logger.warnOrError(e, `Error found in listenForMessageAnchoringEvents: ${JSON.stringify(e)} | Parsed error: ${JSON.stringify(parsedError)}`);
        }
    }
}
exports.AnchoredEventListener = AnchoredEventListener;
