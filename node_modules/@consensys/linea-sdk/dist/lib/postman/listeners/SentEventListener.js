"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SentEventListener = void 0;
const EventParser_1 = require("../../contracts/EventParser");
const errorHandlers_1 = require("../../errorHandlers");
const constants_1 = require("../../utils/constants");
const MessageRepository_1 = require("../repositories/MessageRepository");
const enums_1 = require("../utils/enums");
const errors_1 = require("../utils/errors");
const helpers_1 = require("../utils/helpers");
class SentEventListener {
    constructor(dataSource, messageServiceContract, config, direction) {
        this.messageServiceContract = messageServiceContract;
        this.direction = direction;
        this.maxBlocksToFetchLogs = Math.max(config.listener.maxBlocksToFetchLogs ?? constants_1.DEFAULT_MAX_BLOCKS_TO_FETCH_LOGS, 0);
        this.shouldStopListening = false;
        this.messageRepository = new MessageRepository_1.MessageRepository(dataSource);
        this.originContractAddress = config.messageServiceContractAddress;
        this.pollingInterval = config.listener.pollingInterval ?? constants_1.DEFAULT_LISTENER_INTERVAL;
        this.blockConfirmation = config.listener.blockConfirmation ?? constants_1.DEFAULT_LISTENER_BLOCK_CONFIRMATIONS;
        this.initialFromBlock = config.listener.initialFromBlock;
        this.isEOAEnabled = config.isEOAEnabled ?? constants_1.DEFAULT_EOA_ENABLED;
        this.isCalldataEnabled = config.isCalldataEnabled ?? constants_1.DEFAULT_CALLDATA_ENABLED;
    }
    calculateFromBlockNumber(fromBlockNumber, toBlockNumber) {
        if (fromBlockNumber > toBlockNumber) {
            return toBlockNumber;
        }
        return Math.max(fromBlockNumber, 0);
    }
    async getLatestMessageSentBlockNumber(direction) {
        try {
            const lastMessageSent = await this.messageRepository.getLatestMessageSent(direction, this.originContractAddress);
            if (!lastMessageSent) {
                return null;
            }
            return lastMessageSent.sentBlockNumber;
        }
        catch (error) {
            this.logger.error(error);
            return null;
        }
    }
    async start() {
        this.logger.info(`Starting ${this.direction} SentEventListener...`);
        let fromBlock = await this.messageServiceContract.getCurrentBlockNumber();
        const fromBlockLogIndex = 0;
        const latestMessageSentBlockNumber = await this.getLatestMessageSentBlockNumber(this.direction);
        if (latestMessageSentBlockNumber) {
            fromBlock = latestMessageSentBlockNumber;
        }
        if (this.initialFromBlock || this.initialFromBlock === 0) {
            fromBlock = this.initialFromBlock;
        }
        if (!this.shouldStopListening) {
            this.listenForMessageSentEvents(this.pollingInterval, fromBlock, fromBlockLogIndex);
        }
    }
    stop() {
        this.logger.info(`Stopping ${this.direction} SentEventListener...`);
        this.shouldStopListening = true;
        this.logger.info(`${this.direction} SentEventListener stopped.`);
    }
    async listenForMessageSentEvents(interval, fromBlock, fromBlockLogIndex) {
        const latestBlockNumber = Math.max((await this.messageServiceContract.getCurrentBlockNumber()) - this.blockConfirmation, 0);
        const toBlock = Math.min(latestBlockNumber, fromBlock + this.maxBlocksToFetchLogs);
        fromBlock = this.calculateFromBlockNumber(fromBlock, toBlock);
        this.logger.info(`Interval reached every ${interval} ms, checking from ${fromBlock} to ${toBlock}`);
        try {
            const events = await this.messageServiceContract.getEvents(this.messageServiceContract.contract.filters.MessageSent(), fromBlock, toBlock, fromBlockLogIndex);
            this.logger.info(`# of fetched MessageSent events: ${events.length}`);
            for (const event of events) {
                const shouldBeProcessed = this.shouldProcessMessage(event.args?._calldata, event.args?._messageHash);
                const messageStatusToInsert = shouldBeProcessed ? enums_1.MessageStatus.SENT : enums_1.MessageStatus.EXCLUDED;
                const message = EventParser_1.EventParser.parsedEventToMessage(event, this.direction, messageStatusToInsert);
                this.logger.info(`message: ${JSON.stringify(message.messageHash)}`);
                await this.messageRepository.insertMessage(message);
            }
            fromBlock = toBlock + 1;
            fromBlockLogIndex = 0;
        }
        catch (e) {
            if (e instanceof errors_1.DatabaseAccessError) {
                fromBlock = e.rejectedMessage.sentBlockNumber;
                fromBlockLogIndex = e.rejectedMessage.logIndex;
                this.logger.warn(`${e.message} fromBlockNum = ${fromBlock} fromLogIndex = ${fromBlockLogIndex}`);
            }
            else {
                const parsedError = errorHandlers_1.ErrorParser.parseErrorWithMitigation(e);
                this.logger.warnOrError(e, `Error found in listenForMessageSentEvents: ${JSON.stringify(e)} | Parsed error: ${JSON.stringify(parsedError)}`);
            }
        }
        await (0, helpers_1.wait)(interval);
        if (!this.shouldStopListening) {
            this.listenForMessageSentEvents(interval, fromBlock, fromBlockLogIndex);
        }
    }
    shouldProcessMessage(messageCalldata, messageHash) {
        if ((0, helpers_1.isEmptyBytes)(messageCalldata)) {
            if (this.isEOAEnabled) {
                return true;
            }
        }
        else {
            if (this.isCalldataEnabled) {
                return true;
            }
        }
        this.logger.debug(`Message with hash ${messageHash} has been excluded because target address is not an EOA or calldata is not empty.`);
        return false;
    }
}
exports.SentEventListener = SentEventListener;
