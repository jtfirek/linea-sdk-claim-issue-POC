"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ErrorParser = void 0;
const errors_1 = require("../utils/errors");
const errors_2 = require("../postman/utils/errors");
class ErrorParser {
    static parseErrorWithMitigation(error) {
        if (!error) {
            return null;
        }
        const parsedErrResult = {
            errorCode: "UNKNOWN_ERROR",
            mitigation: { shouldRetry: false },
        };
        switch (error.code) {
            case "NETWORK_ERROR":
            case "SERVER_ERROR":
            case "TIMEOUT":
            case "INSUFFICIENT_FUNDS":
            case "REPLACEMENT_UNDERPRICED":
            case "NONCE_EXPIRED":
                parsedErrResult.context = error.shortMessage;
                parsedErrResult.mitigation = {
                    shouldRetry: true,
                };
                break;
            case "CALL_EXCEPTION":
                if (error.shortMessage.includes("execution reverted") ||
                    error.info?.error?.code === 4001 || //The user rejected the request (EIP-1193)
                    error.info?.error?.code === -32603 //Internal JSON-RPC error (EIP-1474)
                ) {
                    parsedErrResult.context = error.info?.error?.message ?? error.shortMessage;
                    break;
                }
                if (error.info?.error?.code === -32000 && //Missing or invalid parameters (EIP-1474)
                    (error.info?.error?.message.includes("gas required exceeds allowance (0)") ||
                        error.info?.error?.message.includes("max priority fee per gas higher than max fee per gas") ||
                        error.info?.error?.message.includes("max fee per gas less than block base fee"))) {
                    parsedErrResult.context = error.info?.error?.message;
                    parsedErrResult.mitigation = {
                        shouldRetry: true,
                    };
                    break;
                }
                parsedErrResult.context = error.shortMessage;
                parsedErrResult.mitigation = {
                    shouldRetry: true,
                };
                break;
            case "ACTION_REJECTED":
            case "UNKNOWN_ERROR":
                parsedErrResult.context = error.shortMessage;
                break;
            default:
                if (error instanceof errors_1.GasEstimationError) {
                    parsedErrResult.context = error.message;
                    break;
                }
                if (error instanceof errors_2.DatabaseAccessError) {
                    parsedErrResult.context = error.message;
                }
                else {
                    parsedErrResult.context = error.message;
                }
                parsedErrResult.context = error.shortMessage ?? error.message;
                parsedErrResult.mitigation = {
                    shouldRetry: true,
                };
                break;
        }
        return {
            ...parsedErrResult,
            errorCode: error.code || parsedErrResult.errorCode,
        };
    }
}
exports.ErrorParser = ErrorParser;
