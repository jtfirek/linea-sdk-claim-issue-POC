import { BytesLike, Overrides, ContractTransactionResponse } from "ethers";
import { L1MessageServiceContract, L2MessageServiceContract } from "../../contracts";
import { OnChainMessageStatus } from "../../utils/enum";
import { Message, Network } from "../../utils/types";
import { Proof } from "../merkleTree/types";
import { FinalizationMessagingInfo } from "./types";
export declare class L1ClaimingService {
    readonly l1Contract: L1MessageServiceContract;
    readonly l2Contract: L2MessageServiceContract;
    private readonly network;
    private cache;
    constructor(l1Contract: L1MessageServiceContract, l2Contract: L2MessageServiceContract, network: Network);
    getFinalizationMessagingInfo(transactionHash: string): Promise<FinalizationMessagingInfo>;
    getL2MessageHashesInBlockRange(fromBlock: number, toBlock: number): Promise<string[]>;
    getMessageSiblings(messageHash: string, messageHashes: string[], treeDepth: number): string[];
    isMessageSentAfterMigrationBlock(messageHash: string, migrationBlock: number): Promise<boolean>;
    findMigrationBlock(): Promise<number | null>;
    getMessageProof(messageHash: string): Promise<Proof>;
    isClaimingNeedingProof(messageHash: string): Promise<boolean>;
    getMessageStatus(messageHash: BytesLike, overrides?: Overrides): Promise<OnChainMessageStatus>;
    private getMessageStatusUsingMessageHash;
    private getMessageStatusUsingMerkleTree;
    estimateClaimMessageGas(message: Message & {
        feeRecipient?: string;
    }, overrides?: Overrides): Promise<bigint>;
    claimMessage(message: Message & {
        feeRecipient?: string;
    }, overrides?: Overrides): Promise<ContractTransactionResponse>;
}
