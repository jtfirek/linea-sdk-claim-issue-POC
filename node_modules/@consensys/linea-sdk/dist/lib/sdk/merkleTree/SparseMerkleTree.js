"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SparseMerkleTree = void 0;
const ethers_1 = require("ethers");
class MerkleTreeNode {
    constructor(value, left = null, right = null) {
        this.value = value;
        this.left = left;
        this.right = right;
    }
}
class SparseMerkleTree {
    constructor(depth) {
        if (depth <= 1) {
            throw new Error("Merkle tree depth must be greater than 1");
        }
        this.depth = depth;
        this.emptyLeaves = this.generateEmptyLeaves(this.depth);
        this.root = this.createDefaultNode(this.depth);
    }
    addLeaf(key, value) {
        const binaryKey = this.keyToBinary(key);
        this.root = this.insert(this.root, binaryKey, value, 0);
    }
    getProof(key) {
        if (key < 0 || key >= Math.pow(2, this.depth)) {
            throw new Error(`Leaf index is out of range`);
        }
        const binaryKey = this.keyToBinary(key);
        const leaf = this.getLeaf(key);
        if (leaf === this.emptyLeaves[0]) {
            throw new Error(`Leaf does not exist`);
        }
        return {
            proof: this.createProof(this.root, binaryKey, 0).reverse(),
            root: this.root.value,
            leafIndex: key,
        };
    }
    getLeaf(key) {
        if (key < 0 || key >= Math.pow(2, this.depth)) {
            throw new Error("Leaf index is out of range");
        }
        const binaryKey = this.keyToBinary(key);
        return this.getLeafHelper(this.root, binaryKey, 0);
    }
    getRoot() {
        return this.root.value;
    }
    keyToBinary(key) {
        return key.toString(2).padStart(this.depth, "0");
    }
    getLeafHelper(node, binaryKey, depth) {
        if (depth === this.depth) {
            return node.value;
        }
        const newDepth = this.depth - depth - 1;
        const newNode = new MerkleTreeNode(this.emptyLeaves[newDepth]);
        if (binaryKey[depth] === "0") {
            return this.getLeafHelper(node.left || newNode, binaryKey, depth + 1);
        }
        return this.getLeafHelper(node.right || newNode, binaryKey, depth + 1);
    }
    insert(node, key, value, depth) {
        if (depth === this.depth) {
            return new MerkleTreeNode(value);
        }
        const newDepth = this.depth - depth - 1;
        const defaultNode = this.createDefaultNode(newDepth);
        let newLeft = node.left;
        let newRight = node.right;
        if (key[depth] === "0") {
            newLeft = this.insert(node.left || defaultNode, key, value, depth + 1);
        }
        else {
            newRight = this.insert(node.right || defaultNode, key, value, depth + 1);
        }
        return new MerkleTreeNode(
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion, @typescript-eslint/no-non-null-asserted-optional-chain
        this.hash(newLeft?.value, newRight?.value), newLeft, newRight);
    }
    createProof(node, key, depth) {
        if (depth === this.depth) {
            return [];
        }
        const newDepth = this.depth - depth - 1;
        const defaultNode = this.createDefaultNode(newDepth);
        if (key[depth] === "0") {
            const nextNode = node.left || defaultNode;
            const value = node.right ? node.right.value : this.emptyLeaves[newDepth];
            return [value].concat(this.createProof(nextNode, key, depth + 1));
        }
        const nextNode = node.right || defaultNode;
        const value = node.left ? node.left.value : this.emptyLeaves[newDepth];
        return [value].concat(this.createProof(nextNode, key, depth + 1));
    }
    hash(left, right) {
        return ethers_1.ethers.solidityPackedKeccak256(["bytes32", "bytes32"], [left, right]);
    }
    generateEmptyLeaves(depth) {
        const emptyLeaves = [ethers_1.ethers.ZeroHash];
        for (let i = 1; i < depth; i++) {
            emptyLeaves.push(this.hash(emptyLeaves[i - 1], emptyLeaves[i - 1]));
        }
        return emptyLeaves;
    }
    createDefaultNode(depth) {
        if (depth === 0) {
            return new MerkleTreeNode(this.emptyLeaves[0]);
        }
        const child = this.createDefaultNode(depth - 1);
        return new MerkleTreeNode(this.hash(this.emptyLeaves[depth - 1], this.emptyLeaves[depth - 1]), child, child);
    }
}
exports.SparseMerkleTree = SparseMerkleTree;
