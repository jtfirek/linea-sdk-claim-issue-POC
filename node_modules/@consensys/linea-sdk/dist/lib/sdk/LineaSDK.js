"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LineaSDK = void 0;
const contracts_1 = require("../contracts");
const L2MessageReadOnlyProvider_1 = require("../contracts/L2MessageReadOnlyProvider");
const constants_1 = require("../utils/constants");
const networks_1 = require("../utils/networks");
const ProviderService_1 = __importDefault(require("./ProviderService"));
const L1ClaimingService_1 = require("./claiming/L1ClaimingService");
class LineaSDK {
    constructor(options) {
        this.network = options.network;
        this.mode = options.mode;
        this.l2MessageTreeDepth = options.l2MessageTreeDepth ?? constants_1.DEFAULT_L2_MESSAGE_TREE_DEPTH;
        if (options.mode === "read-write") {
            this.l1SignerPrivateKey = options.l1SignerPrivateKey;
            this.l2SignerPrivateKey = options.l2SignerPrivateKey;
            this.maxFeePerGas = options.feeEstimatorOptions?.maxFeePerGas;
            this.gasFeeEstimationPercentile = options.feeEstimatorOptions?.gasFeeEstimationPercentile;
        }
        this.l1Provider = new ProviderService_1.default(options.l1RpcUrl);
        this.l2Provider = new ProviderService_1.default(options.l2RpcUrl);
    }
    getL1Contract(localL1ContractAddress, localL2ContractAddress) {
        let l1ContractAddress;
        let l2ContractAddress;
        if (this.network === "localhost") {
            if (!localL1ContractAddress || !localL2ContractAddress) {
                throw new Error("You need to provide both L1 and L2 local contract address.");
            }
            l1ContractAddress = localL1ContractAddress;
            l2ContractAddress = localL2ContractAddress;
        }
        else {
            l1ContractAddress = networks_1.NETWORKS[this.network].l1ContractAddress;
            l2ContractAddress = networks_1.NETWORKS[this.network].l2ContractAddress;
        }
        const l2MessageReadOnlyProvider = new L2MessageReadOnlyProvider_1.L2MessageReadOnlyProvider(this.l2Provider.provider, l2ContractAddress, this.l2MessageTreeDepth);
        const signer = this.mode === "read-write" ? this.l1Provider.getSigner(this.l1SignerPrivateKey) : undefined;
        return new contracts_1.L1MessageServiceContract(this.l1Provider.provider, l1ContractAddress, l2MessageReadOnlyProvider, this.mode, signer, this.maxFeePerGas, this.gasFeeEstimationPercentile);
    }
    getL2Contract(localContractAddress) {
        let l2ContractAddress;
        if (this.network === "localhost") {
            if (!localContractAddress) {
                throw new Error("You need to provide a contract address.");
            }
            l2ContractAddress = localContractAddress;
        }
        else {
            l2ContractAddress = networks_1.NETWORKS[this.network].l2ContractAddress;
        }
        const signer = this.mode === "read-write" ? this.l2Provider.getSigner(this.l2SignerPrivateKey) : undefined;
        return new contracts_1.L2MessageServiceContract(this.l2Provider.provider, l2ContractAddress, this.mode, signer, this.maxFeePerGas, this.gasFeeEstimationPercentile);
    }
    getL1ClaimingService(localL1ContractAddress, localL2ContractAddress) {
        return new L1ClaimingService_1.L1ClaimingService(this.getL1Contract(localL1ContractAddress, localL2ContractAddress), this.getL2Contract(localL2ContractAddress), this.network);
    }
}
exports.LineaSDK = LineaSDK;
