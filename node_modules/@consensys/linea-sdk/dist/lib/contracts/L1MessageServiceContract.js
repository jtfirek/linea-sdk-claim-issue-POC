"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.L1MessageServiceContract = void 0;
const ethers_1 = require("ethers");
const typechain_1 = require("../../typechain");
const EventParser_1 = require("./EventParser");
const EIP1559GasProvider_1 = require("./EIP1559GasProvider");
const errors_1 = require("../utils/errors");
const constants_1 = require("../utils/constants");
const enum_1 = require("../utils/enum");
const mappers_1 = require("../utils/mappers");
const MerkleTreeFactory_1 = require("../sdk/merkleTree/MerkleTreeFactory");
const helpers_1 = require("../utils/helpers");
class L1MessageServiceContract extends EIP1559GasProvider_1.EIP1559GasProvider {
    constructor(provider, contractAddress, l2MessageReadOnlyProvider, mode, signer, maxFeePerGas, gasEstimationPercentile, isMaxGasFeeEnforced) {
        super(provider, maxFeePerGas, gasEstimationPercentile, isMaxGasFeeEnforced);
        this.provider = provider;
        this.contractAddress = contractAddress;
        this.l2MessageReadOnlyProvider = l2MessageReadOnlyProvider;
        this.mode = mode;
        this.signer = signer;
        this.contract = this.getContract(this.contractAddress, this.signer);
    }
    /**
     * Get the LineaRollup contract abi.
     * @returns The LineaRollup contract abi.
     */
    getContractAbi() {
        return typechain_1.LineaRollup__factory.abi;
    }
    /**
     * Get message information by message hash.
     * @param messageHash The hash of the message sent on L1.
     * @returns Message information (messageSender,destination,fee,value,messageNonce,calldata,messageHash).
     */
    async getMessageByMessageHash(messageHash) {
        const messageSentFilter = this.contract.filters.MessageSent(undefined, undefined, undefined, undefined, undefined, undefined, messageHash);
        const [event] = await this.contract.queryFilter(messageSentFilter, 0, "latest");
        if (!event) {
            return null;
        }
        return (0, mappers_1.mapMessageSentEventOrLogToMessage)(event);
    }
    /**
     * Get messages information by transaction hash.
     * @param transactionHash The hash of the sendMessage transaction on L1.
     * @returns An array of message information (messageSender,destination,fee,value,messageNonce,calldata,messageHash).
     */
    async getMessagesByTransactionHash(transactionHash) {
        const receipt = await this.provider.getTransactionReceipt(transactionHash);
        if (!receipt) {
            return null;
        }
        return receipt.logs
            .filter((log) => log.address === this.contractAddress && log.topics[0] === constants_1.MESSAGE_SENT_EVENT_SIGNATURE)
            .map((log) => this.contract.interface.parseLog(log))
            .map((log) => (log ? (0, mappers_1.mapMessageSentEventOrLogToMessage)(log) : null))
            .filter((log) => log !== null);
    }
    /**
     * Get transaction receipt by message hash.
     * @param messageHash The hash of the message sent on L1.
     * @returns The sendMessage transaction receipt.
     */
    async getTransactionReceiptByMessageHash(messageHash) {
        const messageSentFilter = this.contract.filters.MessageSent(undefined, undefined, undefined, undefined, undefined, undefined, messageHash);
        const [event] = await this.contract.queryFilter(messageSentFilter, 0, "latest");
        if (!event) {
            return null;
        }
        const receipt = await this.provider.getTransactionReceipt(event.transactionHash);
        if (!receipt) {
            return null;
        }
        return receipt;
    }
    /**
     * Get the LineaRollup contract instance.
     * @param contractAddress Address of the L1 contract.
     * @param signer L1 ethers signer instance.
     * @returns The LineaRollup contract instance.
     */
    getContract(contractAddress, signer) {
        if (this.mode === "read-only") {
            return typechain_1.LineaRollup__factory.connect(contractAddress, this.provider);
        }
        if (!signer) {
            throw new Error("Please provide a signer.");
        }
        return typechain_1.LineaRollup__factory.connect(contractAddress, signer);
    }
    /**
     * Get the current account nonce.
     * @param accountAddress Account address.
     * @returns The nonce of the accountAddress passed as param or the l1 signer address.
     */
    async getCurrentNonce(accountAddress) {
        if (this.mode === "read-only") {
            if (!accountAddress) {
                throw new Error("Please provider an account address.");
            }
            return await this.provider.getTransactionCount(accountAddress);
        }
        if (!this.signer) {
            throw new Error("Please provide a signer.");
        }
        return await this.provider.getTransactionCount(await this.signer.getAddress());
    }
    /**
     * Get the current L1 block number.
     * @returns The current L1 block number.
     */
    async getCurrentBlockNumber() {
        return await this.provider.getBlockNumber();
    }
    /**
     * Get events emitted on L1.
     * @param eventFilter The event filter.
     * @param fromBlock The earliest block to seach for events.
     * @param toBlock The latest block to search for events.
     * @param fromBlockLogIndex Block log index.
     * @returns A list of events.
     */
    async getEvents(eventFilter, fromBlock, toBlock, fromBlockLogIndex) {
        let events = await this.contract.queryFilter(eventFilter, fromBlock, toBlock);
        events = events.filter((event) => {
            if (typeof fromBlockLogIndex === "undefined" || typeof fromBlock === "undefined") {
                return true;
            }
            if (event.blockNumber === fromBlock && event.index < fromBlockLogIndex) {
                return false;
            }
            return true;
        });
        if (events.length > 0) {
            return EventParser_1.EventParser.filterAndParseEvents(events);
        }
        return [];
    }
    /**
     * Get the L2 message status on L1 using message hash (for messages sent before migration).
     * @param messageHash The hash of the message sent on L2.
     * @param overrides Ethers call overrides.
     * @returns Message status (CLAIMED, CLAIMABLE, UNKNOWN).
     */
    async getMessageStatusUsingMessageHash(messageHash, overrides = {}) {
        let status = await this.contract.inboxL2L1MessageStatus(messageHash, overrides);
        if (status === BigInt(constants_1.MESSAGE_UNKNOWN_STATUS)) {
            const filter = this.contract.filters.MessageClaimed(messageHash);
            const events = await this.getEvents(filter, 0, "latest");
            if (events.length > 0) {
                status = BigInt(constants_1.MESSAGE_CLAIMED_STATUS);
            }
        }
        return (0, helpers_1.formatMessageStatus)(status);
    }
    /**
     * Get the L2 message status on L1.
     * @param messageHash The hash of the message sent on L2.
     * @param overrides Ethers call overrides.
     * @returns Message status (CLAIMED, CLAIMABLE, UNKNOWN).
     */
    async getMessageStatus(messageHash, overrides = {}) {
        return this.getMessageStatusUsingMerkleTree(messageHash, overrides);
    }
    async getMessageStatusUsingMerkleTree(messageHash, overrides = {}) {
        const [messageEvent] = await this.l2MessageReadOnlyProvider.getMessageSentEventsByMessageHash(messageHash);
        if (!messageEvent) {
            throw new Error(`Message hash does not exist on L2. Message hash: ${messageHash}`);
        }
        const [[l2MessagingBlockAnchoredEvent], isMessageClaimed] = await Promise.all([
            this.getEvents(this.contract.filters.L2MessagingBlockAnchored(messageEvent.blockNumber)),
            this.contract.isMessageClaimed(messageEvent.args._nonce, overrides),
        ]);
        if (isMessageClaimed) {
            return enum_1.OnChainMessageStatus.CLAIMED;
        }
        if (l2MessagingBlockAnchoredEvent) {
            return enum_1.OnChainMessageStatus.CLAIMABLE;
        }
        return enum_1.OnChainMessageStatus.UNKNOWN;
    }
    /**
     * Estimate claimMessage transaction gas.
     * @param message Message information object (messageSender,destination,fee,value,messageNonce,calldata,messageHash).
     * @param overrides Ethers payable overrides.
     * @returns The claimMessage transaction gas estimation.
     */
    async estimateClaimWithoutProofGas(message, overrides = {}) {
        if (this.mode === "read-only") {
            throw new Error("'EstimateClaimGas' function not callable using readOnly mode.");
        }
        const { messageSender, destination, fee, value, calldata, messageNonce, feeRecipient } = message;
        const l1FeeRecipient = feeRecipient ?? ethers_1.ethers.ZeroAddress;
        try {
            return await this.contract.claimMessage.estimateGas(messageSender, destination, fee, value, l1FeeRecipient, calldata, messageNonce, {
                ...(await this.get1559Fees()),
                ...overrides,
            });
        }
        catch (e) {
            throw new errors_1.GasEstimationError(e, message);
        }
    }
    /**
     * Estimate claimMessageWithProof transaction gas.
     * @param message Message information object (messageSender,destination,fee,value,messageNonce,calldata,messageHash).
     * @param overrides Ethers payable overrides.
     * @returns The claimMessageWithProof transaction gas estimation.
     */
    async estimateClaimGas(message, overrides = {}) {
        if (this.mode === "read-only") {
            throw new Error("'EstimateClaimGas' function not callable using readOnly mode.");
        }
        try {
            const merkleTreeInfo = await this.getMessageProof(message.messageHash);
            return await this.estimateClaimWithProofGas({
                ...message,
                merkleRoot: merkleTreeInfo.root,
                proof: merkleTreeInfo.proof,
                leafIndex: merkleTreeInfo.leafIndex,
            }, overrides);
        }
        catch (e) {
            throw new errors_1.GasEstimationError(e, message);
        }
    }
    /**
     * Claims the message on L1.
     * @param message Message information object (messageSender,destination,fee,value,messageNonce,calldata,messageHash).
     * @param overrides Ethers payable overrides.
     * @returns The claimMessage transaction info.
     */
    async claimWithoutProof(message, overrides = {}) {
        if (this.mode === "read-only") {
            throw new Error("'claim' function not callable using readOnly mode.");
        }
        const { messageSender, destination, fee, value, calldata, messageNonce, feeRecipient } = message;
        const l1FeeRecipient = feeRecipient ?? ethers_1.ethers.ZeroAddress;
        return await this.contract.claimMessage(messageSender, destination, fee, value, l1FeeRecipient, calldata, messageNonce, {
            ...(await this.get1559Fees()),
            ...overrides,
        });
    }
    /**
     * Claims the message on L1.
     * @param message Message information object (messageSender,destination,fee,value,messageNonce,calldata,messageHash).
     * @param overrides Ethers payable overrides.
     * @returns The claimMessage transaction info.
     */
    async claim(message, overrides = {}) {
        if (this.mode === "read-only") {
            throw new Error("'claim' function not callable using readOnly mode.");
        }
        const merkleTreeInfo = await this.getMessageProof(message.messageHash);
        return this.claimWithProof({
            ...message,
            merkleRoot: merkleTreeInfo.root,
            proof: merkleTreeInfo.proof,
            leafIndex: merkleTreeInfo.leafIndex,
        }, overrides);
    }
    async getFinalizationMessagingInfo(transactionHash) {
        const receipt = await this.provider.getTransactionReceipt(transactionHash);
        if (!receipt || receipt.logs.length === 0) {
            throw new Error(`Transaction does not exist or no logs found in this transaction: ${transactionHash}.`);
        }
        let treeDepth = 0;
        const l2MerkleRoots = [];
        const blocksNumber = [];
        const filteredLogs = receipt.logs.filter((log) => log.address === this.contractAddress);
        for (const log of filteredLogs) {
            const parsedLog = this.contract.interface.parseLog(log);
            if (log.topics[0] === constants_1.L2_MERKLE_TREE_ADDED_EVENT_SIGNATURE) {
                treeDepth = parseInt(parsedLog?.args.treeDepth);
                l2MerkleRoots.push(parsedLog?.args.l2MerkleRoot);
            }
            else if (log.topics[0] === constants_1.L2_MESSAGING_BLOCK_ANCHORED_EVENT_SIGNATURE) {
                blocksNumber.push(Number(parsedLog?.args.l2Block));
            }
        }
        if (l2MerkleRoots.length === 0) {
            throw new Error(`No L2MerkleRootAdded events found in this transaction.`);
        }
        if (blocksNumber.length === 0) {
            throw new Error(`No L2MessagingBlocksAnchored events found in this transaction.`);
        }
        return {
            l2MessagingBlocksRange: {
                startingBlock: Math.min(...blocksNumber),
                endBlock: Math.max(...blocksNumber),
            },
            l2MerkleRoots,
            treeDepth,
        };
    }
    async getL2MessageHashesInBlockRange(fromBlock, toBlock) {
        const events = await this.l2MessageReadOnlyProvider.getMessageSentEventsByBlockRange(fromBlock, toBlock);
        if (events.length === 0) {
            throw new Error(`No MessageSent events found in this block range on L2.`);
        }
        return events.map((event) => event.args._messageHash);
    }
    getMessageSiblings(messageHash, messageHashes, treeDepth) {
        const numberOfMessagesInTrees = 2 ** treeDepth;
        const messageHashesLength = messageHashes.length;
        const messageHashIndex = messageHashes.indexOf(messageHash);
        if (messageHashIndex === -1) {
            throw new Error("Message hash not found in messages.");
        }
        const start = Math.floor(messageHashIndex / numberOfMessagesInTrees) * numberOfMessagesInTrees;
        const end = Math.min(messageHashesLength, start + numberOfMessagesInTrees);
        const siblings = messageHashes.slice(start, end);
        const remainder = siblings.length % numberOfMessagesInTrees;
        if (remainder !== 0) {
            siblings.push(...Array(numberOfMessagesInTrees - remainder).fill(ethers_1.ethers.ZeroHash));
        }
        return siblings;
    }
    async getMessageProof(messageHash) {
        const [messageEvent] = await this.l2MessageReadOnlyProvider.getMessageSentEventsByMessageHash(messageHash);
        if (!messageEvent) {
            throw new Error(`Message hash does not exist on L2. Message hash: ${messageHash}`);
        }
        const [l2MessagingBlockAnchoredEvent] = await this.getEvents(this.contract.filters.L2MessagingBlockAnchored(messageEvent.blockNumber));
        if (!l2MessagingBlockAnchoredEvent) {
            throw new Error(`L2 block number ${messageEvent.blockNumber} has not been finalized on L1.`);
        }
        const finalizationInfo = await this.getFinalizationMessagingInfo(l2MessagingBlockAnchoredEvent.transactionHash);
        const l2MessageHashesInBlockRange = await this.getL2MessageHashesInBlockRange(finalizationInfo.l2MessagingBlocksRange.startingBlock, finalizationInfo.l2MessagingBlocksRange.endBlock);
        const l2messages = this.getMessageSiblings(messageHash, l2MessageHashesInBlockRange, finalizationInfo.treeDepth);
        const merkleTreeFactory = new MerkleTreeFactory_1.SparseMerkleTreeFactory(this.l2MessageReadOnlyProvider.l2MessageTreeDepth);
        const tree = merkleTreeFactory.createAndAddLeaves(l2messages);
        if (!finalizationInfo.l2MerkleRoots.includes(tree.getRoot())) {
            throw new Error("Merkle tree build failed.");
        }
        return tree.getProof(l2messages.indexOf(messageHash));
    }
    /**
     * Retry a specific transaction.
     * @param transactionHash The hash of the transaction.
     * @param overrides EIP1559 fees info.
     * @returns The transaction information.
     */
    async retryTransactionWithHigherFee(transactionHash, overrides = {}) {
        if (this.mode === "read-only") {
            throw new Error("'retryTransactionWithHigherFee' function not callable using readOnly mode.");
        }
        if (!this.signer) {
            throw new Error("Please provide a signer.");
        }
        const transaction = await this.provider.getTransaction(transactionHash);
        if (!transaction) {
            throw new Error(`Transaction with hash ${transactionHash} not found.`);
        }
        const updatedTransaction = {
            to: transaction.to,
            value: transaction.value,
            data: transaction.data,
            nonce: transaction.nonce,
            gasLimit: transaction.gasLimit,
            chainId: transaction.chainId,
            type: 2,
            ...(await this.get1559Fees()),
            ...overrides,
        };
        const signedTransaction = await this.signer.signTransaction(updatedTransaction);
        return await this.provider.broadcastTransaction(signedTransaction);
    }
    /**
     * Estimate claimMessageWithProof transaction gas.
     * @param message Message information object (messageSender,destination,fee,value,messageNonce,calldata,messageHash,proof,leafIndex,merkleRoot).
     * @param overrides Ethers payable overrides.
     * @returns The claimMessageWithProof transaction gas estimation.
     */
    async estimateClaimWithProofGas(messageWithProof, overrides = {}) {
        if (this.mode === "read-only") {
            throw new Error("'EstimateClaimWithProofGas' function not callable using readOnly mode.");
        }
        const { messageSender, destination, fee, value, calldata, messageNonce, feeRecipient, proof, leafIndex, merkleRoot, } = messageWithProof;
        const l1FeeRecipient = feeRecipient ?? ethers_1.ethers.ZeroAddress;
        try {
            return await this.contract.claimMessageWithProof.estimateGas({
                from: messageSender,
                to: destination,
                fee,
                value,
                data: calldata,
                messageNumber: messageNonce,
                proof,
                leafIndex,
                merkleRoot,
                feeRecipient: l1FeeRecipient,
            }, {
                ...(await this.get1559Fees()),
                ...overrides,
            });
        }
        catch (e) {
            throw new errors_1.GasEstimationError(e, messageWithProof);
        }
    }
    /**
     * Claims the message using merkle proof on L1.
     * @param message Message information object (messageSender,destination,fee,value,messageNonce,calldata,messageHash,proof,leafIndex,merkleRoot).
     * @param overrides Ethers payable overrides.
     * @returns The claimMessageWithProof transaction info.
     */
    async claimWithProof(message, overrides = {}) {
        if (this.mode === "read-only") {
            throw new Error("'claimWithProof' function not callable using readOnly mode.");
        }
        const { messageSender, destination, fee, value, calldata, messageNonce, feeRecipient, proof, leafIndex, merkleRoot, } = message;
        const l1FeeRecipient = feeRecipient ?? ethers_1.ethers.ZeroAddress;
        return await this.contract.claimMessageWithProof({
            from: messageSender,
            to: destination,
            fee,
            value,
            data: calldata,
            messageNumber: messageNonce,
            proof,
            leafIndex,
            merkleRoot,
            feeRecipient: l1FeeRecipient,
        }, {
            ...(await this.get1559Fees()),
            ...overrides,
        });
    }
}
exports.L1MessageServiceContract = L1MessageServiceContract;
