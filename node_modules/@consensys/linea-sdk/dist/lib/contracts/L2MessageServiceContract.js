"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.L2MessageServiceContract = void 0;
const ethers_1 = require("ethers");
const EventParser_1 = require("./EventParser");
const typechain_1 = require("../../typechain");
const EIP1559GasProvider_1 = require("./EIP1559GasProvider");
const errors_1 = require("../utils/errors");
const helpers_1 = require("../utils/helpers");
const mappers_1 = require("../utils/mappers");
const constants_1 = require("../utils/constants");
class L2MessageServiceContract extends EIP1559GasProvider_1.EIP1559GasProvider {
    constructor(provider, contractAddress, mode, signer, maxFeePerGas, gasEstimationPercentile, enforceMaxGasFee) {
        super(provider, maxFeePerGas, gasEstimationPercentile, enforceMaxGasFee);
        this.provider = provider;
        this.contractAddress = contractAddress;
        this.mode = mode;
        this.signer = signer;
        this.contract = this.getContract(this.contractAddress, this.signer);
    }
    /**
     * Get the L2MessageService contract abi.
     * @returns The L2MessageService contract abi.
     */
    getContractAbi() {
        return typechain_1.L2MessageService__factory.abi;
    }
    /**
     * Get message information by message hash.
     * @param messageHash The hash of the message sent on L2.
     * @returns Message information (messageSender,destination,fee,value,messageNonce,calldata,messageHash).
     */
    async getMessageByMessageHash(messageHash) {
        const messageSentFilter = this.contract.filters.MessageSent(undefined, undefined, undefined, undefined, undefined, undefined, messageHash);
        const [event] = await this.contract.queryFilter(messageSentFilter, 0, "latest");
        if (!event) {
            return null;
        }
        return (0, mappers_1.mapMessageSentEventOrLogToMessage)(event);
    }
    /**
     * Get messages information by transaction hash.
     * @param transactionHash The hash of the sendMessage transaction on L2.
     * @returns An array of message information (messageSender,destination,fee,value,messageNonce,calldata,messageHash).
     */
    async getMessagesByTransactionHash(transactionHash) {
        const receipt = await this.provider.getTransactionReceipt(transactionHash);
        if (!receipt) {
            return null;
        }
        return receipt.logs
            .filter((log) => log.address === this.contractAddress && log.topics[0] === constants_1.MESSAGE_SENT_EVENT_SIGNATURE)
            .map((log) => this.contract.interface.parseLog(log))
            .map((log) => (log ? (0, mappers_1.mapMessageSentEventOrLogToMessage)(log) : null))
            .filter((log) => log !== null);
    }
    /**
     * Get transaction receipt by message hash.
     * @param messageHash The hash of the message sent on L2.
     * @returns The sendMessage transaction receipt.
     */
    async getTransactionReceiptByMessageHash(messageHash) {
        const messageSentFilter = this.contract.filters.MessageSent(undefined, undefined, undefined, undefined, undefined, undefined, messageHash);
        const [event] = await this.contract.queryFilter(messageSentFilter, 0, "latest");
        if (!event) {
            return null;
        }
        const receipt = await this.provider.getTransactionReceipt(event.transactionHash);
        if (!receipt) {
            return null;
        }
        return receipt;
    }
    /**
     * Get the L2MessageService contract instance.
     * @param contractAddress Address of the L2 contract.
     * @param signer L2 ethers signer instance.
     * @returns The L2MessageService contract instance.
     */
    getContract(contractAddress, signer) {
        if (this.mode === "read-only") {
            return typechain_1.L2MessageService__factory.connect(contractAddress, this.provider);
        }
        if (!signer) {
            throw new Error("Please provide a signer.");
        }
        return typechain_1.L2MessageService__factory.connect(contractAddress, signer);
    }
    /**
     * Get the current account nonce.
     * @param accountAddress Account address.
     * @returns The nonce of the accountAddress passed as param or the l2 signer address.
     */
    async getCurrentNonce(accountAddress) {
        if (this.mode === "read-only") {
            if (!accountAddress) {
                throw new Error("Please provider an account address.");
            }
            return await this.provider.getTransactionCount(accountAddress);
        }
        if (!this.signer) {
            throw new Error("Please provide a signer.");
        }
        return await this.provider.getTransactionCount(await this.signer.getAddress());
    }
    /**
     * Get the current L2 block number.
     * @returns The current L2 block number.
     */
    async getCurrentBlockNumber() {
        return await this.provider.getBlockNumber();
    }
    /**
     * Get events emitted on L2.
     * @param eventFilter The event filter.
     * @param fromBlock The earliest block to seach for events.
     * @param toBlock The latest block to search for events.
     * @param fromBlockLogIndex Block log index.
     * @returns A list of events.
     */
    async getEvents(eventFilter, fromBlock, toBlock, fromBlockLogIndex) {
        let events = await this.contract.queryFilter(eventFilter, fromBlock, toBlock);
        events = events.filter((event) => {
            if (typeof fromBlockLogIndex === "undefined" || typeof fromBlock === "undefined") {
                return true;
            }
            if (event.blockNumber === fromBlock && event.index < fromBlockLogIndex) {
                return false;
            }
            return true;
        });
        if (events.length > 0) {
            return EventParser_1.EventParser.filterAndParseEvents(events);
        }
        return [];
    }
    /**
     * Get the L1 message status on L2.
     * @param messageHash The hash of the message sent on L1.
     * @param overrides Ethers call overrides.
     * @returns Message status (CLAIMED, CLAIMABLE, UNKNOWN).
     */
    async getMessageStatus(messageHash, overrides = {}) {
        const status = await this.contract.inboxL1L2MessageStatus(messageHash, overrides);
        return (0, helpers_1.formatMessageStatus)(status);
    }
    /**
     * Estimate claimMessage transaction gas.
     * @param message Message information object (messageSender,destination,fee,value,messageNonce,calldata,messageHash).
     * @param overrides Ethers payable overrides.
     * @returns The claimMessage transaction gas estimation.
     */
    async estimateClaimGas(message, overrides = {}) {
        if (this.mode === "read-only") {
            throw new Error("'EstimateClaimGas' function not callable using readOnly mode.");
        }
        const { messageSender, destination, fee, value, calldata, messageNonce, feeRecipient } = message;
        const l2FeeRecipient = feeRecipient ?? ethers_1.ethers.ZeroAddress;
        try {
            return await this.contract.claimMessage.estimateGas(messageSender, destination, fee, value, l2FeeRecipient, calldata, messageNonce, {
                ...overrides,
            });
        }
        catch (e) {
            throw new errors_1.GasEstimationError(e, message);
        }
    }
    /**
     * Claims the message on L2.
     * @param message Message information object (messageSender,destination,fee,value,messageNonce,calldata,messageHash).
     * @param overrides Ethers payable overrides.
     * @returns The claimMessage transaction info.
     */
    async claim(message, overrides = {}) {
        if (this.mode === "read-only") {
            throw new Error("'claim' function not callable using readOnly mode.");
        }
        const { messageSender, destination, fee, value, calldata, messageNonce, feeRecipient } = message;
        const l2FeeRecipient = feeRecipient ?? ethers_1.ethers.ZeroAddress;
        return await this.contract.claimMessage(messageSender, destination, fee, value, l2FeeRecipient, calldata, messageNonce, {
            ...overrides,
        });
    }
    /**
     * Retry a specific transaction.
     * @param transactionHash The hash of the transaction.
     * @param overrides EIP1559 fees info.
     * @returns The transaction information.
     */
    async retryTransactionWithHigherFee(transactionHash, overrides = {}) {
        if (this.mode === "read-only") {
            throw new Error("'retryTransactionWithHigherFee' function not callable using readOnly mode.");
        }
        if (!this.signer) {
            throw new Error("Please provide a signer.");
        }
        const transaction = await this.provider.getTransaction(transactionHash);
        if (!transaction) {
            throw new Error(`Transaction with hash ${transactionHash} not found.`);
        }
        const updatedTransaction = {
            to: transaction.to,
            value: transaction.value,
            data: transaction.data,
            nonce: transaction.nonce,
            gasLimit: transaction.gasLimit,
            chainId: transaction.chainId,
            type: 2,
            ...overrides,
        };
        const signedTransaction = await this.signer.signTransaction(updatedTransaction);
        return await this.provider.broadcastTransaction(signedTransaction);
    }
}
exports.L2MessageServiceContract = L2MessageServiceContract;
